---
alwaysApply: true
---

StravaGoals application allows users to define, track, and visualize annual training goals based on generated activity data. Users can create, edit, and delete goals, view the history of changes, and generate suggestions for new or modified goals using a simple AI module.

## Tech Stack

### Frontend

Astro 5.15 - Main framework for pages and routing

Vue 3.5 - Interactive components (Islands Architecture)

TypeScript 5

Tailwind 4.1

### Backend

Supabase

### AI

Openrouter.ai

### CI/CD and Hosting

GitHub Actions for building CI/CD pipelines

mikr.us for hosting the application via a Docker image

## Project Structure

- `./src` - source code
- `./src/pages` - Astro pages (file-based routing): each .astro file becomes a route
- `./src/layouts` - Astro layouts for shared page structure
- `./src/components` - Vue components (interactive islands with client:\* directives)
- `./src/components/ui` - small reusable UI components, e.g. buttons, cards
- `./src/components/layout` - larger structures, e.g. navbar, footer
- `./src/db` - Supabase clients and types
- `./src/plugins` - Vue app configuration (Pinia, Supabase)
- `./src/stores` - Pinia stores for state management
- `./src/assets` - static assets (styles, images, fonts)
- `./public` - public static files served as-is

Always update this section after modifying the directory structure.

## Architecture Notes

The project uses Astro's Islands Architecture:

- **Pages (.astro)**: Static or server-rendered pages with file-based routing
- **Components (.vue)**: Interactive UI components that are hydrated as "islands"
- **Hydration**: Use client:load, client:idle, or client:visible directives on Vue components
- **Routing**: No Vue Router - use standard <a> tags and Astro's file-based routing
- **State Management**: Pinia works in Vue components with client:\* directives
- **Data Fetching**: Can be done server-side in .astro pages or client-side in .vue components

## Coding practices

### Guidelines for clean code

- Use feedback from linters to improve the code when making changes.
- Prioritize error handling and edge cases.
- Handle errors and edge cases at the beginning of functions.
- Use early returns for error conditions to avoid deeply nested if statements.
- Place the happy path last in the function for improved readability.
- Avoid unnecessary else statements; use if-return pattern instead.
- Use guard clauses to handle preconditions and invalid states early.
- Implement proper error logging and user-friendly error messages.
- Consider using custom error types or error factories for consistent error handling.

### Guidelines for SUPPORT_LEVEL

#### SUPPORT_BEGINNER

- When running in agent mode, execute up to 3 actions at a time and ask for approval or course correction afterwards.
- Write code with clear variable names and include explanatory comments for non-obvious logic. Avoid shorthand syntax and complex patterns.
- Provide full implementations rather than partial snippets. Include import statements, required dependencies, and initialization code.
- Add defensive coding patterns and clear error handling. Include validation for user inputs and explicit type checking.
- Suggest simpler solutions first, then offer more optimized versions with explanations of the trade-offs.
- Briefly explain why certain approaches are used and link to relevant documentation or learning resources.
- When suggesting fixes for errors, explain the root cause and how the solution addresses it to build understanding. Ask for confirmation before proceeding.
- Offer introducing basic test cases that demonstrate how the code works and common edge cases to consider.

### Guidelines for ARCHITECTURE

#### CLEAN_ARCHITECTURE

- Strictly separate code into layers: entities, use cases, interfaces, and frameworks
- Ensure dependencies point inward, with inner layers having no knowledge of outer layers
- Implement domain entities that encapsulate {{business_rules}} without framework dependencies
- Use interfaces (ports) and implementations (adapters) to isolate external dependencies
- Create use cases that orchestrate entity interactions for specific business operations
- Implement mappers to transform data between layers to maintain separation of concerns
