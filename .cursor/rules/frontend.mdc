---
globs: ['*.astro', '*.vue', '*.tsx']
alwaysApply: false
---

### Guidelines for ASTRO

#### ASTRO_ARCHITECTURE

- Use Astro's Islands Architecture to minimize JavaScript sent to the client
- Create static pages with .astro files for optimal performance and SEO
- Use Vue components with client directives (client:load, client:idle, client:visible) only when interactivity is needed
- Implement file-based routing in src/pages/ directory for automatic route generation
- Use layouts in src/layouts/ to share common structure across pages
- Leverage Astro's built-in optimizations for images, fonts, and assets
- Use Astro.props for passing data to components and pages
- Implement getStaticPaths() for dynamic routes in static site generation

#### ASTRO_COMPONENTS

- Create .astro components for static content and structure
- Use Vue .vue components for interactive UI elements that require client-side state
- Apply the principle: "Use Astro by default, Vue only when needed"
- Use client:load for components that need immediate interactivity
- Use client:idle for lower-priority interactive components
- Use client:visible for components that should hydrate when visible
- Avoid using client:only unless absolutely necessary
- Pass serializable props to components with client directives (no functions or complex objects)

#### ASTRO_ROUTING

- Organize pages in src/pages/ using file-based routing convention
- Use [...slug].astro for catch-all routes
- Use [param].astro for dynamic parameter routes
- Implement getStaticPaths() for pre-rendering dynamic routes at build time
- Use Astro.redirect() for server-side redirects
- Create \_layout.astro files for nested layouts (Astro handles automatic nesting)

### Guidelines for VUE

#### VUE_CODING_STANDARDS

- Use the Composition API instead of the Options API for better type inference and code reuse
- Implement <script setup> for more concise component definitions
- Use Suspense and async components for handling loading states during code-splitting
- Leverage the defineProps and defineEmits macros for type-safe props and events
- Use the new defineOptions for additional component options
- Implement provide/inject for dependency injection instead of prop drilling in deeply nested components
- Use the Teleport component for portal-like functionality to render UI elsewhere in the DOM
- Leverage ref over reactive for primitive values to avoid unintended unwrapping
- Use v-memo for performance optimization in render-heavy list rendering scenarios
- Implement shallow refs for large objects that don't need deep reactivity

#### VUE_IN_ASTRO

- Vue components in Astro work as interactive islands
- Use Composition API with <script setup> for all Vue components
- Do NOT use Vue Router - Astro handles routing via file-based pages
- Use standard <a> tags for navigation between Astro pages instead of <RouterLink>
- Access route parameters via Astro.params in .astro pages, not in Vue components
- Share state between Vue islands using Pinia stores
- Configure Vue plugins (like Pinia) in src/plugins/vue-app.ts
- Use props to pass data from Astro pages to Vue components
- Avoid using provide/inject across Astro and Vue boundaries
- Remember that Vue components are only interactive when using client:\* directives

#### PINIA

- Create multiple stores based on logical domains instead of a single large store
- Use the setup syntax (defineStore with setup function) for defining stores for better TypeScript inference
- Implement getters for derived state to avoid redundant computations
- Leverage the storeToRefs helper to extract reactive properties while maintaining reactivity
- Use plugins for cross-cutting concerns like persistence, state resets, or dev tools
- Implement actions for asynchronous operations and complex state mutations
- Use composable stores by importing and using stores within other stores
- Leverage the $reset() method to restore initial state when needed
- Implement $subscribe for reactive store subscriptions
- Use TypeScript with proper return type annotations for maximum type safety

### Guidelines for STYLING

#### TAILWIND

- Use the @layer directive to organize styles into components, utilities, and base layers
- Implement Just-in-Time (JIT) mode for development efficiency and smaller CSS bundles
- Use arbitrary values with square brackets (e.g., w-[123px]) for precise one-off designs
- Leverage the @apply directive in component classes to reuse utility combinations
- Implement the Tailwind configuration file for customizing theme, plugins, and variants
- Use component extraction for repeated UI patterns instead of copying utility classes
- Leverage the theme() function in CSS for accessing Tailwind theme values
- Implement dark mode with the dark: variant
- Use responsive variants (sm:, md:, lg:, etc.) for adaptive designs
- Leverage state variants (hover:, focus:, active:, etc.) for interactive elements

### Guidelines for STATIC_ANALYSIS

#### ESLINT

- Configure project-specific rules in eslint.config.js to enforce consistent coding standards
- Use shareable configs like eslint-config-airbnb or eslint-config-standard as a foundation
- Implement custom rules for {{project_specific_patterns}} to maintain codebase consistency
- Configure integration with Prettier to avoid rule conflicts for code formatting
- Use the --fix flag in CI/CD pipelines to automatically correct fixable issues
- Implement staged linting with husky and lint-staged to prevent committing non-compliant code

#### PRETTIER

- Define a consistent .prettierrc configuration across all {{project_repositories}}
- Configure editor integration to format on save for immediate feedback
- Use .prettierignore to exclude generated files, build artifacts, and {{specific_excluded_patterns}}
- Set printWidth based on team preferences (80-120 characters) to improve code readability
- Configure consistent quote style and semicolon usage to match team conventions
- Implement CI checks to ensure all committed code adheres to the defined style
